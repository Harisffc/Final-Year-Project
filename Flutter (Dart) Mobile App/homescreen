import 'package:flutter/foundation.dart'; // For kIsWeb
import 'package:flutter/material.dart';
import 'package:camera/camera.dart';
import 'package:image_picker/image_picker.dart';
import 'dart:typed_data';
import 'dart:io' show File; // Only used on mobile
import 'package:provider/provider.dart';
import 'package:supabase_flutter/supabase_flutter.dart' as supabase; // Alias for Supabase
import 'points_provider.dart'; // Import the PointsProvider
import 'points_screen.dart'; // Ensure PointsScreen is imported

class HomeScreen extends StatelessWidget {
  final List<CameraDescription> cameras;

  HomeScreen({Key? key, required this.cameras}) : super(key: key);

  final List<Map<String, dynamic>> tasks = [
    {'title': 'Donate Food', 'points': 50, 'taskType': 'food'},
    {'title': 'Reusable Bag', 'points': 50, 'taskType': 'bags'},
    {'title': 'Eco-Friendly Travel', 'points': 50, 'taskType': 'transport'},
    {'title': 'Save Water', 'points': 50, 'taskType': 'water'},
    {'title': 'Save Energy', 'points': 50, 'taskType': 'energy'},
  ];

  Future<void> _takePhoto(BuildContext context, String taskType, int points) async {
    final picker = ImagePicker();
    final image = await picker.pickImage(source: ImageSource.camera);

    if (image != null) {
      _askQuestion(context, taskType, points, image);
    }
  }

  void _askQuestion(BuildContext context, String taskType, int points, XFile image) async {
    final controller = TextEditingController();
    String question = '';
    double impact = 0.0; // To store calculated impact (CO2 saved)

    switch (taskType) {
      case 'food':
        question = 'How much food have you donated (kg)?';
        break;
      case 'bags':
        question = 'How much plastic have you avoided (bags)?';
        break;
      case 'transport':
        question = 'How much have you traveled by bicycle (mile)?';
        break;
      case 'water':
        question = 'How much water have you saved (liters)?';
        break;
      case 'energy':
        question = 'How much energy have you saved (kWh)?';
        break;
    }

    // Read image bytes outside of the showDialog
    Uint8List? imageBytes;
    if (kIsWeb) {
      imageBytes = await image.readAsBytes();
    }

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Task Completed!'),
        content: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              kIsWeb
                  ? Image.memory(imageBytes!) // For Web, use Image.memory (base64 encoding)
                  : Image.file(File(image.path)), // For mobile, use Image.file

              const SizedBox(height: 12),
              Text(question, style: const TextStyle(color: Colors.black)),
              const SizedBox(height: 8),
              TextField(
                controller: controller,
                keyboardType: TextInputType.number,
                decoration: const InputDecoration(hintText: 'Enter amount'),
              ),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () async {
              if (controller.text.isNotEmpty) {
                final userId = supabase.Supabase.instance.client.auth.currentUser?.id ?? 'unknown_user';
                final double inputAmount = double.parse(controller.text);

                // Calculate the CO2 impact based on the task type
                impact = _calculateImpact(inputAmount, taskType);

                // Handle image upload depending on platform (web or mobile)
                if (kIsWeb) {
                  final byteData = await image.readAsBytes();
                  final fileName = '${DateTime.now().millisecondsSinceEpoch}_${image.name}';
                  final response = await supabase.Supabase.instance.client.storage
                      .from('photos')
                      .uploadBinary(fileName, byteData);

                  if (response.error == null) {
                    // Add points and then fetch updated points
                    await Provider.of<PointsProvider>(context, listen: false).addPoints(userId, points);
                    await Provider.of<PointsProvider>(context, listen: false).fetchTotalPoints(userId);

                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text('Upload successful!')),
                    );
                    Navigator.pop(context);

                    // Display the impact after task completion
                    _showImpactDialog(context, impact);
                  } else {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text('Error uploading photo: ${response.error?.message}')),
                    );
                  }
                } else {
                  final file = File(image.path);
                  final fileName = '${DateTime.now().millisecondsSinceEpoch}_${file.uri.pathSegments.last}';
                  final response = await supabase.Supabase.instance.client.storage
                      .from('photos')
                      .upload(fileName, file);

                  if (response.error == null) {
                    // Add points and then fetch updated points
                    await Provider.of<PointsProvider>(context, listen: false).addPoints(userId, points);
                    await Provider.of<PointsProvider>(context, listen: false).fetchTotalPoints(userId);

                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text('Upload successful!')),
                    );
                    Navigator.pop(context);

                    // Display the impact after task completion
                    _showImpactDialog(context, impact);
                  } else {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text('Error uploading photo: ${response.error?.message}')),
                    );
                  }
                }
              } else {
                ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Please enter a valid amount.')));
              }
            },
            child: const Text('Submit'),
          ),
        ],
      ),
    );
  }

  // Method to calculate impact based on the task type and user input
  double _calculateImpact(double amount, String taskType) {
    double impact = 0.0;

    switch (taskType) {
      case 'food':
        impact = amount * 0.03; // CO2 saved for donated food (example: 30g per kg of food)
        break;
      case 'bags':
        impact = amount * 0.03; // CO2 saved per plastic bag avoided
        break;
      case 'transport':
        impact = amount * 0.411; // CO2 saved for eco-friendly travel (per mile)
        break;
      case 'water':
        impact = amount * 0.002; // CO2 saved by saving water (per liter)
        break;
      case 'energy':
        impact = amount * 0.4; // CO2 saved by saving energy (per kWh)
        break;
    }

    return impact;
  }

  // Method to show the impact to the user in a dialog
  void _showImpactDialog(BuildContext context, double impact) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Congratulations! 🌍'),
        content: Text(
            'You saved $impact kg of CO₂! \n\nYour efforts are making a real difference!'
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context);
            },
            child: const Text('Close'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        title: const Text('Eco Tasks'),
        backgroundColor: Colors.teal[700],
      ),
      body: ListView.builder(
        itemCount: tasks.length,
        itemBuilder: (context, index) {
          var task = tasks[index];
          return TaskCard(
            title: task['title'],
            points: task['points'],
            taskType: task['taskType'],
            onTakePhoto: () => _takePhoto(context, task['taskType'], task['points']),
          );
        },
      ),
      bottomNavigationBar: BottomNavigationBar(
        items: [
          BottomNavigationBarItem(
            icon: Icon(Icons.home),
            label: 'Home',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.star),
            label: 'Points',
          ),
        ],
        onTap: (index) {
          if (index == 1) {
            Navigator.push(
              context,
              MaterialPageRoute(builder: (context) => PointsScreen()),
            );
          }
        },
      ),
    );
  }
}

// TaskCard widget displaying each task
class TaskCard extends StatelessWidget {
  final String title;
  final int points;
  final String taskType;
  final VoidCallback onTakePhoto;

  const TaskCard({
    Key? key,
    required this.title,
    required this.points,
    required this.taskType,
    required this.onTakePhoto,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.symmetric(vertical: 10, horizontal: 15),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              title,
              style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            Text(
              'Points: $points',
              style: const TextStyle(color: Colors.grey),
            ),
            const SizedBox(height: 12),
            ElevatedButton.icon(
              icon: const Icon(Icons.camera_alt),
              label: const Text('Take Photo'),
              onPressed: onTakePhoto,
              style: ElevatedButton.styleFrom(
                foregroundColor: Colors.black,
                backgroundColor: Colors.yellowAccent,
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

